[
  {
    "projectId": "d400a9a9-6203-4b2d-9d57-a29b4e44b03f",
    "testId": "ea8589f3-bdd9-473d-9cdc-de00d81630c7",
    "userId": "64789468-0061-70f5-8fc0-f9d6c509a178",
    "title": "TC001-test secure multi role authentication login",
    "description": "Verify that the authentication system supports login with name, phone number, and role-based credentials, including fallback to local authentication and proper session management.",
    "code": "import requests\n\nBASE_AUTH_URL = \"http://localhost:8000\"\nLOGIN_ENDPOINT = \"/api/auth/login\"\nLOGOUT_ENDPOINT = \"/api/auth/logout\"\nTIMEOUT = 30\n\ndef test_secure_multi_role_authentication_login():\n    login_url = BASE_AUTH_URL + LOGIN_ENDPOINT\n    logout_url = BASE_AUTH_URL + LOGOUT_ENDPOINT\n\n    # Test credentials provided\n    credentials = {\n        \"email\": \"marketing.manager@example.com\",\n        \"password\": \"password123\"\n    }\n\n    session = requests.Session()\n\n    try:\n        # Step 1: Login using email and password credentials\n        login_resp = session.post(login_url, json=credentials, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n        login_data = login_resp.json()\n        assert \"token\" in login_data or \"sessionId\" in login_data or \"user\" in login_data, \"Missing authentication token/session in response\"\n        # If token-based, set Authorization header for the session\n        token = login_data.get(\"token\")\n        if token:\n            session.headers.update({\"Authorization\": f\"Bearer {token}\"})\n\n        # Step 2: Verify role information presence in response (role-based access)\n        user_info = login_data.get(\"user\") or {}\n        user_role = user_info.get(\"role\") or login_data.get(\"role\")\n        assert user_role, \"No role information returned in login response\"\n\n        # Step 3: Test login fallback with phone number and role-based info (simulate another login)\n        # Assuming API accepts username as phone or name, here use Admin username and password from instructions\n        fallback_credentials = {\"username\": \"Admin\", \"password\": \"9876543225\"}\n        fallback_login_resp = requests.post(\n            login_url, json=fallback_credentials, timeout=TIMEOUT\n        )\n        assert fallback_login_resp.status_code == 200, f\"Fallback login failed with status {fallback_login_resp.status_code}\"\n        fallback_data = fallback_login_resp.json()\n        assert \"token\" in fallback_data or \"sessionId\" in fallback_data or \"user\" in fallback_data, \"Missing token/session in fallback login response\"\n\n        # Step 4: Confirm session consistency - logout and then verify access is revoked\n        logout_resp = session.post(logout_url, timeout=TIMEOUT)\n        assert logout_resp.status_code == 200 or logout_resp.status_code == 204, f\"Logout failed with status {logout_resp.status_code}\"\n\n        # After logout, access to protected endpoint should be denied\n        protected_url = BASE_AUTH_URL + \"/api/employees\"  # example protected resource\n        protected_resp = session.get(protected_url, timeout=TIMEOUT)\n        # Expect unauthorized after logout\n        assert protected_resp.status_code in (401, 403), \"Access to protected resource not denied after logout\"\n\n    except requests.RequestException as e:\n        assert False, f\"RequestException during test: {e}\"\n    finally:\n        session.close()\n\ntest_secure_multi_role_authentication_login()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 61, in <module>\n  File \"<string>\", line 23, in test_secure_multi_role_authentication_login\nAssertionError: Login failed with status 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-08T11:07:49.326Z",
    "modified": "2025-09-08T11:08:38.515Z"
  },
  {
    "projectId": "d400a9a9-6203-4b2d-9d57-a29b4e44b03f",
    "testId": "c4bec58c-8f79-476a-bf88-a582033f997a",
    "userId": "64789468-0061-70f5-8fc0-f9d6c509a178",
    "title": "TC002-test role based dashboard access control",
    "description": "Ensure that users with different roles (Super Admin, Admin, Manager, Employee, Freelancer, Intern) see the correct personalized dashboard and cannot access unauthorized dashboards.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nLOGIN_ENDPOINT = \"/api/auth/login\"\nDASHBOARD_ENDPOINTS = {\n    \"Super Admin\": \"/api/super-admin/dashboard\",\n    \"Admin\": \"/api/admin/dashboard\",\n    \"Manager\": \"/api/manager/dashboard\",\n    \"Employee\": \"/api/employee/dashboard\",\n    \"Freelancer\": \"/api/freelancer/dashboard\",\n    \"Intern\": \"/api/intern/dashboard\"\n}\nTIMEOUT = 30\n\n# Test credentials for various roles (assuming these are set in the test system)\nROLE_CREDENTIALS = {\n    \"Super Admin\": {\"email\": \"super.admin@example.com\", \"password\": \"password123\"},\n    \"Admin\": {\"email\": \"admin@example.com\", \"password\": \"password123\"},\n    \"Manager\": {\"email\": \"marketing.manager@example.com\", \"password\": \"password123\"},\n    \"Employee\": {\"email\": \"employee@example.com\", \"password\": \"password123\"},\n    \"Freelancer\": {\"email\": \"freelancer@example.com\", \"password\": \"password123\"},\n    \"Intern\": {\"email\": \"intern@example.com\", \"password\": \"password123\"},\n}\n\n# Authorized dashboards mapping per role - list of dashboards each role can access\nROLE_AUTHORIZED_DASHBOARDS = {\n    \"Super Admin\": set(DASHBOARD_ENDPOINTS.values()),\n    \"Admin\": set(DASHBOARD_ENDPOINTS.values()) - {DASHBOARD_ENDPOINTS[\"Super Admin\"]},\n    \"Manager\": {DASHBOARD_ENDPOINTS[\"Manager\"]},\n    \"Employee\": {DASHBOARD_ENDPOINTS[\"Employee\"]},\n    \"Freelancer\": {DASHBOARD_ENDPOINTS[\"Freelancer\"]},\n    \"Intern\": {DASHBOARD_ENDPOINTS[\"Intern\"]},\n}\n\ndef login(email, password, role):\n    payload = {\"email\": email, \"password\": password}\n    try:\n        response = requests.post(\n            BASE_URL + LOGIN_ENDPOINT,\n            json=payload,\n            timeout=TIMEOUT\n        )\n        response.raise_for_status()\n        data = response.json()\n        token = data.get(\"token\")\n        assert token, \"Login successful but token not found in response\"\n        return token\n    except requests.RequestException as e:\n        raise AssertionError(f\"Login failed for {email}: {str(e)}\")\n\ndef test_role_based_dashboard_access_control():\n    for role, creds in ROLE_CREDENTIALS.items():\n        token = login(creds[\"email\"], creds[\"password\"], role)\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        \n        # Check access to all dashboards\n        for dashboard_role, endpoint in DASHBOARD_ENDPOINTS.items():\n            url = BASE_URL + endpoint\n            try:\n                response = requests.get(url, headers=headers, timeout=TIMEOUT)\n            except requests.RequestException as e:\n                assert False, f\"Request to {url} failed for role {role}: {str(e)}\"\n            \n            if endpoint in ROLE_AUTHORIZED_DASHBOARDS[role]:\n                # Should be accessible: expect 200 OK and valid JSON dashboard data\n                assert response.status_code == 200, (\n                    f\"Role {role} should have access to {dashboard_role} dashboard at {endpoint}, \"\n                    f\"but got HTTP {response.status_code}\"\n                )\n                try:\n                    data = response.json()\n                except Exception:\n                    assert False, f\"Role {role} got non-JSON response at {endpoint}\"\n                # Basic sanity check: dashboard should contain \"dashboard\" or \"data\" key\n                assert any(k in data for k in (\"dashboard\", \"data\", \"user\", \"role\")), (\n                    f\"Role {role} dashboard response missing expected keys at {endpoint}\"\n                )\n            else:\n                # Should not be accessible: expect 403 Forbidden or 401 Unauthorized\n                assert response.status_code in (401, 403), (\n                    f\"Role {role} should NOT have access to {dashboard_role} dashboard at {endpoint}, \"\n                    f\"but got HTTP {response.status_code}\"\n                )\n\ntest_role_based_dashboard_access_control()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 43, in login\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 401 Client Error: Unauthorized for url: http://localhost:8000/api/auth/login\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 85, in <module>\n  File \"<string>\", line 53, in test_role_based_dashboard_access_control\n  File \"<string>\", line 49, in login\nAssertionError: Login failed for super.admin@example.com: 401 Client Error: Unauthorized for url: http://localhost:8000/api/auth/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-08T11:07:49.331Z",
    "modified": "2025-09-08T11:09:16.218Z"
  },
  {
    "projectId": "d400a9a9-6203-4b2d-9d57-a29b4e44b03f",
    "testId": "43c640ff-54e6-483c-89dd-acd87a800066",
    "userId": "64789468-0061-70f5-8fc0-f9d6c509a178",
    "title": "TC003-test client onboarding and management workflow",
    "description": "Validate the client onboarding process, including service tracking and client dashboard data accuracy.",
    "code": "import requests\nfrom requests.exceptions import RequestException\n\nBASE_URL_AUTH = \"http://localhost:8000\"\nBASE_URL_APP = \"http://localhost:5173\"\nLOGIN_ENDPOINT = \"/api/auth/login\"\nLOGOUT_ENDPOINT = \"/api/auth/logout\"\nCLIENTS_ENDPOINT = \"/api/clients\"\nWORKSPACES_ENDPOINT = \"/api/workspaces\"\nLIVE_DATA_ENDPOINT = \"/api/live-data\"\n\nEMAIL = \"marketing.manager@example.com\"\nPASSWORD = \"password123\"\n\nTIMEOUT = 30\n\ndef test_client_onboarding_and_management_workflow():\n    session = requests.Session()\n    token = None\n    created_client_id = None\n    headers_auth = None\n    workspace_id = None\n    try:\n        # 1. Authenticate and get token\n        login_payload = {\"email\": EMAIL, \"password\": PASSWORD}\n        login_resp = session.post(\n            BASE_URL_AUTH + LOGIN_ENDPOINT,\n            json=login_payload,\n            timeout=TIMEOUT\n        )\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        login_data = login_resp.json()\n        assert \"token\" in login_data, \"No auth token found in login response\"\n        token = login_data[\"token\"]\n        headers_auth = {\"Authorization\": f\"Bearer {token}\", \"Content-Type\": \"application/json\"}\n\n        # 2. Create a workspace (if needed for client onboarding)\n        workspace_payload = {\n            \"name\": \"Test Workspace for Client Onboarding\",\n            \"description\": \"Workspace created during onboarding test\"\n        }\n        workspace_resp = session.post(\n            BASE_URL_APP + WORKSPACES_ENDPOINT,\n            json=workspace_payload,\n            headers=headers_auth,\n            timeout=TIMEOUT\n        )\n        assert workspace_resp.status_code == 201, f\"Workspace creation failed: {workspace_resp.text}\"\n        workspace_data = workspace_resp.json()\n        workspace_id = workspace_data.get(\"id\")\n        assert workspace_id is not None, \"Workspace ID missing in response\"\n\n        # 3. Onboard a new client\n        client_onboard_payload = {\n            \"name\": \"Test Client Onboarding\",\n            \"email\": \"client.onboarding@example.com\",\n            \"phone\": \"1234567890\",\n            \"workspace_id\": workspace_id,\n            \"services\": [\"SEO\", \"PPC\"],\n            \"billing_details\": {\n                \"billing_cycle\": \"monthly\",\n                \"payment_method\": \"credit_card\"\n            },\n            \"address\": \"123 Client St, Marketing City\"\n        }\n        client_resp = session.post(\n            BASE_URL_APP + CLIENTS_ENDPOINT,\n            json=client_onboard_payload,\n            headers=headers_auth,\n            timeout=TIMEOUT\n        )\n        assert client_resp.status_code == 201, f\"Client onboarding failed: {client_resp.text}\"\n        client_data = client_resp.json()\n        created_client_id = client_data.get(\"id\")\n        assert created_client_id is not None, \"Client ID missing in onboarding response\"\n        assert client_data.get(\"name\") == client_onboard_payload[\"name\"], \"Client name mismatch\"\n        assert set(client_data.get(\"services\", [])) == set(client_onboard_payload[\"services\"]), \"Services mismatch\"\n\n        # 4. Track service information for the created client - get client details to check service tracking\n        client_detail_resp = session.get(\n            f\"{BASE_URL_APP}{CLIENTS_ENDPOINT}/{created_client_id}\",\n            headers=headers_auth,\n            timeout=TIMEOUT\n        )\n        assert client_detail_resp.status_code == 200, f\"Failed to get client details: {client_detail_resp.text}\"\n        client_detail = client_detail_resp.json()\n        assert \"services\" in client_detail, \"Services info missing in client details\"\n        assert set(client_detail[\"services\"]) == set(client_onboard_payload[\"services\"]), \"Client services do not match onboarded services\"\n\n        # 5. Validate client dashboard data accuracy - fetch dashboard info for the client (assuming from live-data or clients endpoint)\n        dashboard_resp = session.get(\n            f\"{BASE_URL_APP}/api/clients/{created_client_id}/dashboard\",\n            headers=headers_auth,\n            timeout=TIMEOUT\n        )\n        # There may or may not be a dedicated client dashboard endpoint; if 404, try live-data with client param\n        if dashboard_resp.status_code == 404:\n            dashboard_resp = session.get(\n                f\"{BASE_URL_APP}{LIVE_DATA_ENDPOINT}\",\n                headers=headers_auth,\n                params={\"client_id\": created_client_id},\n                timeout=TIMEOUT\n            )\n        assert dashboard_resp.status_code == 200, f\"Failed to get client dashboard data: {dashboard_resp.text}\"\n        dashboard_data = dashboard_resp.json()\n\n        # Basic checks on dashboard data presence and structure\n        assert isinstance(dashboard_data, dict), \"Dashboard data is not a dictionary\"\n        # Example keys check: 'projects', 'billing', 'status', 'nps_score', etc. - based on PRD focus\n        expected_keys = {\"projects\", \"billing\", \"client_status\"}\n        # We allow partial presence, but at least one should be present\n        assert any(key in dashboard_data for key in expected_keys), \"No expected dashboard keys present\"\n\n    except RequestException as e:\n        assert False, f\"Request failed: {str(e)}\"\n    finally:\n        # 6. Clean up created client and workspace if created\n        if created_client_id:\n            try:\n                del_client_resp = session.delete(\n                    f\"{BASE_URL_APP}{CLIENTS_ENDPOINT}/{created_client_id}\",\n                    headers=headers_auth,\n                    timeout=TIMEOUT\n                )\n                # Allow 200 or 204 as success for delete\n                assert del_client_resp.status_code in (200, 204), f\"Failed to delete client: {del_client_resp.text}\"\n            except Exception:\n                pass\n\n        if workspace_id:\n            try:\n                del_ws_resp = session.delete(\n                    f\"{BASE_URL_APP}{WORKSPACES_ENDPOINT}/{workspace_id}\",\n                    headers=headers_auth,\n                    timeout=TIMEOUT\n                )\n                assert del_ws_resp.status_code in (200, 204), f\"Failed to delete workspace: {del_ws_resp.text}\"\n            except Exception:\n                pass\n\n        # 7. Logout to end session\n        if token:\n            try:\n                session.post(\n                    BASE_URL_AUTH + LOGOUT_ENDPOINT,\n                    headers=headers_auth,\n                    timeout=TIMEOUT\n                )\n            except Exception:\n                pass\n\ntest_client_onboarding_and_management_workflow()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 152, in <module>\n  File \"<string>\", line 31, in test_client_onboarding_and_management_workflow\nAssertionError: Login failed: {\"error\":\"Invalid credentials\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-08T11:07:49.335Z",
    "modified": "2025-09-08T11:08:40.231Z"
  },
  {
    "projectId": "d400a9a9-6203-4b2d-9d57-a29b4e44b03f",
    "testId": "2049c89a-ea09-4bad-a701-c3d6d5345301",
    "userId": "64789468-0061-70f5-8fc0-f9d6c509a178",
    "title": "TC004-test employee onboarding and hr approval workflow",
    "description": "Check the employee onboarding forms, signup navigation, and HR approval workflows function correctly and update employee profiles.",
    "code": "import requests\n\nBASE_FRONTEND_URL = \"http://localhost:5173\"\nBASE_BACKEND_URL = \"http://localhost:8000\"\nLOGIN_ENDPOINT = \"/api/auth/login\"\nLOGOUT_ENDPOINT = \"/api/auth/logout\"\nEMPLOYEES_ENDPOINT = \"/api/employees\"\n\nAUTH_CREDENTIALS = {\n    \"email\": \"manager@example.com\",\n    \"password\": \"Password123!\"\n}\n\nTIMEOUT = 30\n\n\ndef test_employee_onboarding_and_hr_approval_workflow():\n    session = requests.Session()\n    try:\n        # Login and get auth token / session cookie\n        login_response = session.post(\n            BASE_BACKEND_URL + LOGIN_ENDPOINT,\n            json=AUTH_CREDENTIALS,\n            timeout=TIMEOUT\n        )\n        assert login_response.status_code == 200, f\"Login failed: {login_response.text}\"\n        auth_data = login_response.json()\n        # The system likely returns a token or sets cookies, use session for cookies\n        # Check expected fields to confirm login success\n        assert \"token\" in auth_data or session.cookies, \"Authentication token or cookies missing\"\n\n        headers = {}\n        if \"token\" in auth_data:\n            token = auth_data[\"token\"]\n            headers[\"Authorization\"] = f\"Bearer {token}\"\n\n        # Step 1: Create a new employee onboarding form (simulate onboarding)\n        new_employee_payload = {\n            \"firstName\": \"Test\",\n            \"lastName\": \"Employee\",\n            \"email\": \"test.employee@example.com\",\n            \"position\": \"Marketing Intern\",\n            \"department\": \"Marketing\",\n            \"startDate\": \"2025-10-01\",\n            \"status\": \"onboarding\",\n            \"profileCompleted\": False,\n            \"hrApprovalStatus\": \"pending\"\n        }\n        create_resp = session.post(\n            BASE_BACKEND_URL + EMPLOYEES_ENDPOINT,\n            json=new_employee_payload,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert create_resp.status_code == 201, f\"Employee creation failed: {create_resp.text}\"\n        employee = create_resp.json()\n        assert \"id\" in employee, \"Created employee response missing ID\"\n        employee_id = employee[\"id\"]\n\n        # Step 2: Simulate signup navigation by fetching the employee record\n        get_emp_resp = session.get(\n            f\"{BASE_BACKEND_URL}{EMPLOYEES_ENDPOINT}/{employee_id}\",\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert get_emp_resp.status_code == 200, f\"Fetching employee failed: {get_emp_resp.text}\"\n        employee_data = get_emp_resp.json()\n        # Verify onboarding fields\n        assert employee_data.get(\"status\") == \"onboarding\", \"Employee status should be onboarding\"\n        assert employee_data.get(\"email\") == new_employee_payload[\"email\"], \"Employee email mismatch\"\n\n        # Step 3: Simulate HR approval - update approval status\n        hr_approval_update = {\n            \"hrApprovalStatus\": \"approved\",\n            \"status\": \"active\",\n            \"profileCompleted\": True\n        }\n        update_resp = session.put(\n            f\"{BASE_BACKEND_URL}{EMPLOYEES_ENDPOINT}/{employee_id}\",\n            json=hr_approval_update,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert update_resp.status_code == 200, f\"HR approval update failed: {update_resp.text}\"\n        updated_employee = update_resp.json()\n        assert updated_employee.get(\"hrApprovalStatus\") == \"approved\", \"HR approval status not updated\"\n        assert updated_employee.get(\"status\") == \"active\", \"Employee status not updated to active\"\n        assert updated_employee.get(\"profileCompleted\") is True, \"Profile completion flag not updated\"\n\n        # Step 4: Confirm changes reflect in employee profile\n        final_get_resp = session.get(\n            f\"{BASE_BACKEND_URL}{EMPLOYEES_ENDPOINT}/{employee_id}\",\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert final_get_resp.status_code == 200, f\"Fetching employee after update failed: {final_get_resp.text}\"\n        final_data = final_get_resp.json()\n        assert final_data.get(\"hrApprovalStatus\") == \"approved\", \"Final HR approval status incorrect\"\n        assert final_data.get(\"status\") == \"active\", \"Final employee status incorrect\"\n        assert final_data.get(\"profileCompleted\") is True, \"Final profile completion flag incorrect\"\n\n    finally:\n        # Clean up: delete the created employee to maintain test isolation\n        # Attempt delete only if employee_id exists\n        try:\n            if 'employee_id' in locals():\n                del_resp = session.delete(\n                    f\"{BASE_BACKEND_URL}{EMPLOYEES_ENDPOINT}/{employee_id}\",\n                    headers=headers,\n                    timeout=TIMEOUT\n                )\n                # Allow 200 or 204 as successful deletes\n                assert del_resp.status_code in (200, 204), f\"Failed to delete employee: {del_resp.text}\"\n        except Exception as e:\n            # Log or pass as we must not break test cleanup\n            pass\n\n        # Logout to clean session if possible\n        try:\n            session.post(\n                BASE_BACKEND_URL + LOGOUT_ENDPOINT,\n                headers=headers,\n                timeout=TIMEOUT\n            )\n        except Exception:\n            pass\n\n\ntest_employee_onboarding_and_hr_approval_workflow()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 129, in <module>\n  File \"<string>\", line 26, in test_employee_onboarding_and_hr_approval_workflow\nAssertionError: Login failed: {\"error\":\"Invalid credentials\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-08T11:07:49.340Z",
    "modified": "2025-09-08T11:09:27.208Z"
  },
  {
    "projectId": "d400a9a9-6203-4b2d-9d57-a29b4e44b03f",
    "testId": "65538049-fc9a-4079-9137-ee740d2002f7",
    "userId": "64789468-0061-70f5-8fc0-f9d6c509a178",
    "title": "TC005-test seo module data entry and appraisal linkage",
    "description": "Verify SEO data entry forms, employee and team dashboards, and appraisal system correctly track performance KPIs and enforce role-based access.",
    "code": "import requests\n\nBASE_URL_AUTH = \"http://localhost:8000\"\nBASE_URL_APP = \"http://localhost:5173\"\nLOGIN_ENDPOINT = \"/api/auth/login\"\nLOGOUT_ENDPOINT = \"/api/auth/logout\"\nSEO_DATA_ENTRY_ENDPOINT = \"/api/live-data\"\nEMPLOYEE_DASHBOARD_ENDPOINT = \"/api/employees\"\nTEAM_DASHBOARD_ENDPOINT = \"/api/workspaces\"\nAPPRAISAL_ENDPOINT = \"/api/reports/monthly-tactical\"\n\nTEST_CREDENTIALS = {\n    \"email\": \"manager@example.com\",\n    \"password\": \"managerPass123\"\n}\n\nTIMEOUT = 30\n\ndef test_seo_module_data_entry_and_appraisal_linkage():\n    session = requests.Session()\n    try:\n        # Authenticate and get token\n        login_resp = session.post(\n            BASE_URL_AUTH + LOGIN_ENDPOINT,\n            json=TEST_CREDENTIALS,\n            timeout=TIMEOUT,\n        )\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        login_data = login_resp.json()\n        assert \"token\" in login_data, \"Token missing in login response\"\n        token = login_data[\"token\"]\n\n        headers = {\n            \"Authorization\": f\"Bearer {token}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        # 1. Submit SEO KPI data entry form - create a new live-data record referring SEO KPIs\n        seo_payload = {\n            \"module\": \"seo\",\n            \"kpis\": {\n                \"organic_traffic\": 12500,\n                \"keyword_ranking\": 35,\n                \"backlinks\": 120,\n                \"content_updates\": 4\n            },\n            \"proof_urls\": [\n                \"http://proof.example.com/seo/organic_traffic_report\",\n                \"http://proof.example.com/seo/keyword_ranking_report\"\n            ],\n            \"submitted_by\": \"manager@example.com\"\n        }\n        seo_create_resp = session.post(\n            BASE_URL_APP + SEO_DATA_ENTRY_ENDPOINT,\n            json=seo_payload,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert seo_create_resp.status_code in (200, 201), f\"SEO data entry failed: {seo_create_resp.text}\"\n        seo_data = seo_create_resp.json()\n        assert \"id\" in seo_data, \"Created SEO data entry missing id\"\n        seo_id = seo_data[\"id\"]\n\n        # 2. Verify employee dashboard access and data visibility (for manager@example.com)\n        employee_resp = session.get(\n            BASE_URL_APP + EMPLOYEE_DASHBOARD_ENDPOINT,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert employee_resp.status_code == 200, f\"Employee dashboard access failed: {employee_resp.text}\"\n        employee_data = employee_resp.json()\n        # Check that SEO KPIs data or module data is visible or referenced\n        seo_found = False\n        for entry in employee_data.get(\"seo_kpi_entries\", []):\n            if entry.get(\"id\") == seo_id:\n                seo_found = True\n                break\n        assert seo_found, \"SEO KPI entry not found in employee dashboard\"\n\n        # 3. Verify team dashboard shows aggregated SEO KPI data\n        team_resp = session.get(\n            BASE_URL_APP + TEAM_DASHBOARD_ENDPOINT,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert team_resp.status_code == 200, f\"Team dashboard access failed: {team_resp.text}\"\n        team_data = team_resp.json()\n        # Expect some aggregated SEO KPI summary, e.g. team organic traffic or recent entries count\n        assert \"seo_kpi_summary\" in team_data, \"SEO KPI summary missing in team dashboard\"\n        assert team_data[\"seo_kpi_summary\"].get(\"total_entries\", 0) > 0, \"Team dashboard SEO KPI summary empty\"\n\n        # 4. Verify appraisal system correctly tracks the SEO KPI and enforces role-based access\n        # Try to fetch appraisal report for the user\n        appraisal_resp = session.get(\n            BASE_URL_APP + APPRAISAL_ENDPOINT,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert appraisal_resp.status_code == 200, f\"Appraisal report access failed: {appraisal_resp.text}\"\n        appraisal_data = appraisal_resp.json()\n        # Verify appraisal data contains SEO KPI linkage & performance scoring related to the SEO ID\n        appraisal_entries = appraisal_data.get(\"appraisals\", [])\n        linked_in_appraisal = False\n        for appraisal in appraisal_entries:\n            if appraisal.get(\"related_seo_data_id\") == seo_id:\n                linked_in_appraisal = True\n                # Check presence of performance KPIs and appraisal score\n                assert \"performance_kpis\" in appraisal, \"Performance KPIs missing in appraisal\"\n                assert \"score\" in appraisal, \"Appraisal score missing\"\n                break\n        assert linked_in_appraisal, \"SEO data entry not linked in appraisal system\"\n\n        # 5. Attempt unauthorized access test for restricted roles by altering token (simulate as Intern)\n        # Note: For test simplicity, we'll try to fetch appraisal with an invalid token that simulates no access\n        unauthorized_headers = {\n            \"Authorization\": \"Bearer invalid_or_intern_token\",\n            \"Content-Type\": \"application/json\"\n        }\n        unauthorized_resp = session.get(\n            BASE_URL_APP + APPRAISAL_ENDPOINT,\n            headers=unauthorized_headers,\n            timeout=TIMEOUT,\n        )\n        # Expect unauthorized or forbidden response for restricted role\n        assert unauthorized_resp.status_code in (401, 403), \"Unauthorized access not blocked properly\"\n\n    finally:\n        # Logout to end session\n        try:\n            session.post(BASE_URL_AUTH + LOGOUT_ENDPOINT, headers=headers, timeout=TIMEOUT)\n        except Exception:\n            pass\n\ntest_seo_module_data_entry_and_appraisal_linkage()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 134, in <module>\n  File \"<string>\", line 28, in test_seo_module_data_entry_and_appraisal_linkage\nAssertionError: Login failed: {\"error\":\"Invalid credentials\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-08T11:07:49.345Z",
    "modified": "2025-09-08T11:09:09.698Z"
  },
  {
    "projectId": "d400a9a9-6203-4b2d-9d57-a29b4e44b03f",
    "testId": "f1a5327e-dd29-4271-b92e-e85b6c5684ca",
    "userId": "64789468-0061-70f5-8fc0-f9d6c509a178",
    "title": "TC006-test kpi and performance tracking submission",
    "description": "Test interactive KPI forms, quick submission forms, and monthly reporting dashboards for correct data capture and display.",
    "code": "import requests\n\nBASE_URL_BACKEND = \"http://localhost:8000\"\nBASE_URL_FRONTEND = \"http://localhost:5173\"\nLOGIN_ENDPOINT = \"/api/auth/login\"\nLOGOUT_ENDPOINT = \"/api/auth/logout\"\nMONTHLY_REPORT_ENDPOINT = \"/api/reports/monthly-tactical\"\nLIVE_DATA_ENDPOINT = \"/api/live-data\"\nHEADERS_COMMON = {\"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\ndef test_kpi_and_performance_tracking_submission():\n    session = requests.Session()\n    auth_headers = None\n    try:\n        # 1. Authenticate and get token\n        login_resp = session.post(\n            BASE_URL_BACKEND + LOGIN_ENDPOINT,\n            json={\"username\": \"marketing.manager@example.com\", \"password\": \"password123\"},\n            headers=HEADERS_COMMON,\n            timeout=TIMEOUT,\n        )\n        assert login_resp.status_code == 200, \"Login failed\"\n        login_data = login_resp.json()\n        token = login_data.get(\"token\")\n        assert token, \"No token received on login\"\n\n        auth_headers = {\n            \"Authorization\": f\"Bearer {token}\",\n            \"Content-Type\": \"application/json\",\n        }\n\n        # 2. Submit an interactive KPI form (simulate quick submission with KPIs and proof URL)\n        interactive_kpi_payload = {\n            \"reportingMonth\": \"2025-09\",\n            \"employeeId\": login_data.get(\"user\", {}).get(\"id\"),\n            \"kpis\": [\n                {\"kpiId\": \"seo_traffic\", \"value\": 1500, \"proofUrl\": \"http://proof.example.com/seo_traffic.png\"},\n                {\"kpiId\": \"leads_generated\", \"value\": 30, \"proofUrl\": \"http://proof.example.com/leads_report.pdf\"},\n            ],\n            \"comments\": \"KPI quick submission for September 2025\",\n        }\n        submit_resp = session.post(\n            BASE_URL_BACKEND + MONTHLY_REPORT_ENDPOINT,\n            json=interactive_kpi_payload,\n            headers=auth_headers,\n            timeout=TIMEOUT,\n        )\n        assert submit_resp.status_code in (200, 201), f\"Failed KPI submission: {submit_resp.text}\"\n        submit_data = submit_resp.json()\n        report_id = submit_data.get(\"id\")\n        assert report_id, \"No report ID returned after KPI submission\"\n\n        # 3. Retrieve the monthly reporting dashboard data to verify submission presence and correctness\n        dashboard_resp = session.get(\n            f\"{BASE_URL_BACKEND}/api/reports/monthly-tactical?month=2025-09&employeeId={interactive_kpi_payload['employeeId']}\",\n            headers=auth_headers,\n            timeout=TIMEOUT,\n        )\n        assert dashboard_resp.status_code == 200, \"Failed to fetch monthly tactical reports\"\n        dashboard_data = dashboard_resp.json()\n        # Find the submitted report among fetched data\n        matching_reports = [r for r in dashboard_data if r.get(\"id\") == report_id]\n        assert len(matching_reports) == 1, \"Submitted KPI report not found in monthly dashboard\"\n        report = matching_reports[0]\n\n        # Validate kpi values and proof URLs returned match submitted data\n        received_kpis = report.get(\"kpis\", [])\n        assert len(received_kpis) == len(interactive_kpi_payload[\"kpis\"]), \"Mismatch in number of KPIs returned\"\n        for sent_kpi in interactive_kpi_payload[\"kpis\"]:\n            matched_kpi = next((k for k in received_kpis if k.get(\"kpiId\") == sent_kpi[\"kpiId\"]), None)\n            assert matched_kpi, f\"KPI {sent_kpi['kpiId']} missing in response\"\n            assert matched_kpi.get(\"value\") == sent_kpi[\"value\"], f\"KPI value mismatch for {sent_kpi['kpiId']}\"\n            assert matched_kpi.get(\"proofUrl\") == sent_kpi[\"proofUrl\"], f\"KPI proof URL mismatch for {sent_kpi['kpiId']}\"\n\n        # 4. Verify live KPI data endpoint reflects the new KPI submission (simulate quick submission form dashboard)\n        live_data_resp = session.get(\n            LIVE_DATA_ENDPOINT,\n            headers=auth_headers,\n            timeout=TIMEOUT,\n        )\n        assert live_data_resp.status_code == 200, \"Failed to fetch live KPI data\"\n        live_data = live_data_resp.json()\n        # Check that the KPIs contain submitted values with the same employeeId and month if possible\n        # This is a lightweight check just for presence and reasonable value\n        found = False\n        for record in live_data:\n            if record.get(\"employeeId\") == interactive_kpi_payload[\"employeeId\"] and record.get(\"month\") == \"2025-09\":\n                kpis = record.get(\"kpis\", [])\n                if any(k.get(\"kpiId\") == \"seo_traffic\" and k.get(\"value\") == 1500 for k in kpis):\n                    found = True\n                    break\n        assert found, \"Submitted KPI data not reflected in live KPI data feed\"\n\n    finally:\n        # Logout user session if token available\n        if auth_headers:\n            try:\n                session.post(\n                    BASE_URL_BACKEND + LOGOUT_ENDPOINT,\n                    headers=auth_headers,\n                    timeout=TIMEOUT,\n                )\n            except requests.RequestException:\n                pass\n        session.close()\n\ntest_kpi_and_performance_tracking_submission()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 108, in <module>\n  File \"<string>\", line 23, in test_kpi_and_performance_tracking_submission\nAssertionError: Login failed\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-08T11:07:49.349Z",
    "modified": "2025-09-08T11:09:24.458Z"
  },
  {
    "projectId": "d400a9a9-6203-4b2d-9d57-a29b4e44b03f",
    "testId": "df127a81-9f9f-43e1-bc43-78a5ead71e93",
    "userId": "64789468-0061-70f5-8fc0-f9d6c509a178",
    "title": "TC007-test financial management payment tracking and reporting",
    "description": "Validate financial tracking including recurring and one-time payments, proof URL enforcement, and accurate financial dashboard reporting.",
    "code": "import requests\n\nBASE_URL_AUTH = \"http://localhost:8000\"\nBASE_URL_API = \"http://localhost:5173\"\nLOGIN_ENDPOINT = \"/api/auth/login\"\nLOGOUT_ENDPOINT = \"/api/auth/logout\"\nPAYMENTS_ENDPOINT = \"/api/payments\"\nACCOUNTS_PAYMENTS_ENDPOINT = \"/api/accounts/payments\"\nFINANCIAL_DASHBOARD_ENDPOINT = \"/api/reports/monthly-tactical\"\n\nTEST_EMAIL = \"marketing.manager@example.com\"\nTEST_PASSWORD = \"password123\"\n\nTIMEOUT = 30\n\ndef test_financial_management_payment_tracking_and_reporting():\n    session = requests.Session()\n    token = None\n    try:\n        # Authenticate and get token\n        login_resp = session.post(\n            BASE_URL_AUTH + LOGIN_ENDPOINT,\n            json={\"email\": TEST_EMAIL, \"password\": TEST_PASSWORD},\n            timeout=TIMEOUT\n        )\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        login_data = login_resp.json()\n        assert \"token\" in login_data or \"accessToken\" in login_data, \"Auth token not found in response\"\n        token = login_data.get(\"token\") or login_data.get(\"accessToken\")\n        headers = {\n            \"Authorization\": f\"Bearer {token}\",\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\"\n        }\n        session.headers.update(headers)\n\n        # --- Test creating a recurring payment with proof URL ---\n        recurring_payment_payload = {\n            \"type\": \"recurring\",\n            \"amount\": 1500.75,\n            \"currency\": \"USD\",\n            \"proof_url\": \"http://example.com/proof/recurring_payment_001.pdf\",\n            \"due_date\": \"2025-12-31\",\n            \"status\": \"pending\",\n            \"description\": \"Monthly subscription fee\"\n        }\n        create_rec_resp = session.post(\n            BASE_URL_API + PAYMENTS_ENDPOINT,\n            json=recurring_payment_payload,\n            timeout=TIMEOUT\n        )\n        assert create_rec_resp.status_code == 201, f\"Failed to create recurring payment: {create_rec_resp.text}\"\n        rec_payment_data = create_rec_resp.json()\n        rec_payment_id = rec_payment_data.get(\"id\")\n        assert rec_payment_id is not None, \"Recurring payment ID missing in response\"\n        assert rec_payment_data.get(\"proof_url\") == recurring_payment_payload[\"proof_url\"], \"Proof URL not saved properly\"\n\n        # --- Test creating a one-time payment missing proof URL (should error) ---\n        one_time_payment_payload = {\n            \"type\": \"one-time\",\n            \"amount\": 300.00,\n            \"currency\": \"USD\",\n            \"due_date\": \"2025-10-15\",\n            \"status\": \"pending\",\n            \"description\": \"One-time consulting fee\"\n            # proof_url intentionally missing to test enforcement\n        }\n        create_one_time_resp = session.post(\n            BASE_URL_API + PAYMENTS_ENDPOINT,\n            json=one_time_payment_payload,\n            timeout=TIMEOUT\n        )\n        # Expecting a 400 or 422 error due to missing proof URL\n        assert create_one_time_resp.status_code in [400, 422], \\\n            \"One-time payment creation without proof URL should fail\"\n        error_resp = create_one_time_resp.json()\n        assert \"proof_url\" in str(error_resp).lower() or \"proof\" in str(error_resp).lower(), \\\n            \"Error message should mention missing proof URL\"\n\n        # --- Fetch financial dashboard report and validate data accuracy ---\n        dashboard_resp = session.get(\n            BASE_URL_API + FINANCIAL_DASHBOARD_ENDPOINT,\n            timeout=TIMEOUT\n        )\n        assert dashboard_resp.status_code == 200, f\"Failed to fetch financial dashboard: {dashboard_resp.text}\"\n        dashboard_data = dashboard_resp.json()\n\n        # Validate that the dashboard contains payment summary data\n        assert isinstance(dashboard_data, dict), \"Dashboard data should be a dictionary\"\n        assert \"payments\" in dashboard_data or \"paymentStatusSummary\" in dashboard_data or \"summary\" in dashboard_data, \\\n            \"Dashboard response missing payments summary\"\n\n        # Validate recurring and one-time payments presence in report\n        payments_list = dashboard_data.get(\"payments\") or dashboard_data.get(\"paymentStatusSummary\") or []\n        # Find our recurring payment in the dashboard\n        recurring_found = False\n        for payment in payments_list:\n            if payment.get(\"id\") == rec_payment_id:\n                recurring_found = True\n                # Check fields\n                assert payment.get(\"type\") == \"recurring\", \"Payment type mismatch in dashboard\"\n                assert payment.get(\"proof_url\") == recurring_payment_payload[\"proof_url\"], \"Proof URL mismatch in dashboard payment\"\n                assert payment.get(\"amount\") == recurring_payment_payload[\"amount\"], \"Amount mismatch in dashboard payment\"\n                break\n        assert recurring_found, \"Recurring payment not found in financial dashboard report\"\n\n    finally:\n        # Cleanup: delete recurring payment if created\n        if token and 'rec_payment_id' in locals():\n            try:\n                del_resp = session.delete(\n                    f\"{BASE_URL_API}{PAYMENTS_ENDPOINT}/{rec_payment_id}\",\n                    timeout=TIMEOUT\n                )\n                # It's ok if deletion fails after test, so no assertion on delete\n            except Exception:\n                pass\n\n        # Logout session if authenticated\n        if token:\n            try:\n                session.post(\n                    BASE_URL_AUTH + LOGOUT_ENDPOINT,\n                    timeout=TIMEOUT\n                )\n            except Exception:\n                pass\n\n\ntest_financial_management_payment_tracking_and_reporting()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 130, in <module>\n  File \"<string>\", line 26, in test_financial_management_payment_tracking_and_reporting\nAssertionError: Login failed: {\"error\":\"Invalid credentials\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-08T11:07:49.354Z",
    "modified": "2025-09-08T11:08:43.713Z"
  },
  {
    "projectId": "d400a9a9-6203-4b2d-9d57-a29b4e44b03f",
    "testId": "b32ff739-09f3-4da7-aba3-2c2d4e0545a4",
    "userId": "64789468-0061-70f5-8fc0-f9d6c509a178",
    "title": "TC008-test navigation and protected route role based redirection",
    "description": "Ensure application routing and navigation utilities enforce role-based access and redirect unauthorized users appropriately.",
    "code": "import requests\n\nBASE_API_URL = \"http://localhost:8000\"\nBASE_APP_URL = \"http://localhost:5173\"\nLOGIN_ENDPOINT = \"/api/auth/login\"\nLOGOUT_ENDPOINT = \"/api/auth/logout\"\n\nEMAIL = \"marketing.manager@example.com\"\nPASSWORD = \"password123\"\n\nTIMEOUT = 30\n\n\ndef test_navigation_and_protected_route_role_based_redirection():\n    session = requests.Session()\n    try:\n        # Login to backend API to obtain auth token or session cookie\n        login_resp = session.post(\n            f\"{BASE_API_URL}{LOGIN_ENDPOINT}\",\n            json={\"email\": EMAIL, \"password\": PASSWORD},\n            timeout=TIMEOUT,\n        )\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        login_data = login_resp.json()\n        # We expect token or session cookie; first try token in response\n        token = login_data.get(\"token\")\n        headers = {}\n        if token:\n            headers[\"Authorization\"] = f\"Bearer {token}\"\n        else:\n            # fallback assume session cookie handled by session\n            pass\n\n        # Define a set of restricted endpoints and open endpoints to test navigation & role-based redirects\n        # According to instructions, test that user with marketing manager role:\n        # - can access permitted endpoints\n        # - is redirected or forbidden for unauthorized endpoints\n        # Since no exact mapping is given, we test a few representative endpoints:\n\n        accessible_endpoints = [\n            \"/api/reports/monthly-tactical\",\n            \"/api/sales/leads\",\n            \"/api/notifications\",\n        ]\n        # endpoints that marketing manager likely cannot access (Admin/Super Admin routes)\n        protected_endpoints = [\n            \"/api/employees\",\n            \"/api/clients\",\n            \"/api/workspaces\",\n            \"/api/payments\",\n            \"/api/audit/logs\",\n        ]\n\n        # Check allowed access endpoints\n        for ep in accessible_endpoints:\n            resp = session.get(f\"{BASE_API_URL}{ep}\", headers=headers, timeout=TIMEOUT)\n            assert resp.status_code == 200, f\"Access to {ep} denied unexpectedly: {resp.status_code} {resp.text}\"\n            try:\n                data = resp.json()\n                assert isinstance(data, (dict, list)), f\"Invalid JSON response at {ep}\"\n            except Exception as e:\n                assert False, f\"Response JSON parse error at {ep}: {str(e)}\"\n\n        # Check protected endpoints - expect 403 Forbidden or 401 Unauthorized or redirection\n        for ep in protected_endpoints:\n            resp = session.get(f\"{BASE_API_URL}{ep}\", headers=headers, timeout=TIMEOUT)\n            # Accept 401 or 403 as expected denial, or redirect status (3xx)\n            assert resp.status_code in (401, 403), (\n                f\"Unauthorized access not enforced for {ep}. \"\n                f\"Status: {resp.status_code}, Response: {resp.text}\"\n            )\n\n        # Additional check: verify navigation to frontend protected route redirects unauthorized user properly\n        # Since this is frontend on localhost:5173, simulate navigation by requesting protected routes without valid role\n        # For simplicity, test a known protected frontend route (simulate fetching HTML)\n\n        protected_frontend_paths = [\n            \"/admin/dashboard\",\n            \"/employees/manage\",\n            \"/finance/payments\",\n        ]\n        for path in protected_frontend_paths:\n            # request without frontend auth headers (simulate unauthorized user)\n            resp = requests.get(f\"{BASE_APP_URL}{path}\", timeout=TIMEOUT, allow_redirects=False)\n            # Expect redirect status to login or landing page (e.g. 302 or 303)\n            assert resp.status_code in (302, 303), (\n                f\"Frontend protected route {path} did not redirect unauthorized user. \"\n                f\"Status: {resp.status_code}\"\n            )\n            location = resp.headers.get(\"Location\", \"\")\n            assert location, f\"Redirect missing Location header on {path}\"\n            # Location should be login or home page path on frontend\n            assert any(login_path in location for login_path in [\"/login\", \"/\"]), (\n                f\"Redirect location for {path} unexpected: {location}\"\n            )\n\n        # Now simulate login to frontend with marketing manager and check role-based dashboard or route access\n\n        # Login at frontend (simulate form post to backend)\n        frontend_login_resp = session.post(\n            f\"{BASE_API_URL}{LOGIN_ENDPOINT}\",\n            json={\"email\": EMAIL, \"password\": PASSWORD},\n            timeout=TIMEOUT,\n        )\n        assert frontend_login_resp.status_code == 200, f\"Frontend login failed: {frontend_login_resp.text}\"\n\n        # After login, access marketing manager dashboard\n        marketing_dashboard_path = \"/manager/dashboard\"\n        resp = session.get(f\"{BASE_APP_URL}{marketing_dashboard_path}\", timeout=TIMEOUT)\n        # Should be accessible: 200 OK with HTML or JSON content\n        assert resp.status_code == 200, f\"Marketing Manager dashboard not accessible: {resp.status_code}\"\n\n        # Attempt accessing unauthorized role dashboard and expect redirect to not authorized page or dashboard home\n        unauthorized_dashboard_paths = [\n            \"/admin/dashboard\",\n            \"/superadmin/dashboard\",\n        ]\n        for path in unauthorized_dashboard_paths:\n            resp = session.get(f\"{BASE_APP_URL}{path}\", timeout=TIMEOUT, allow_redirects=False)\n            assert resp.status_code in (302, 303), (\n                f\"Unauthorized dashboard {path} did not redirect user. Status: {resp.status_code}\"\n            )\n            location = resp.headers.get(\"Location\", \"\")\n            assert location, f\"Redirect missing Location header on {path}\"\n            assert any(page in location for page in [\"/manager/dashboard\", \"/not-authorized\", \"/\"]), (\n                f\"Redirect location for {path} unexpected: {location}\"\n            )\n    finally:\n        # Logout for cleanup/session end\n        session.post(f\"{BASE_API_URL}{LOGOUT_ENDPOINT}\", timeout=TIMEOUT)\n\n\ntest_navigation_and_protected_route_role_based_redirection()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 133, in <module>\n  File \"<string>\", line 23, in test_navigation_and_protected_route_role_based_redirection\nAssertionError: Login failed: {\"error\":\"Invalid credentials\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-08T11:07:49.358Z",
    "modified": "2025-09-08T11:08:45.671Z"
  },
  {
    "projectId": "d400a9a9-6203-4b2d-9d57-a29b4e44b03f",
    "testId": "6fafb97c-9a67-40ba-99af-af5bb9f729d6",
    "userId": "64789468-0061-70f5-8fc0-f9d6c509a178",
    "title": "TC009-test notification center real time alerts and management",
    "description": "Verify the notification system delivers real-time alerts, respects user preferences, and allows notification management.",
    "code": "import requests\nimport time\n\nBASE_AUTH_URL = \"http://localhost:8000\"\nBASE_API_URL = \"http://localhost:5173\"\nLOGIN_ENDPOINT = \"/api/auth/login\"\nLOGOUT_ENDPOINT = \"/api/auth/logout\"\nNOTIFICATIONS_ENDPOINT = \"/api/notifications\"\nUSER_PREFS_ENDPOINT = \"/api/notifications/preferences\"\n\nEMAIL = \"marketing.manager@example.com\"\nPASSWORD = \"password123\"\nTIMEOUT = 30\n\ndef test_notification_center_real_time_alerts_and_management():\n    session = requests.Session()\n    token = None\n    notification_id = None\n\n    try:\n        # Step 1: Authenticate user and retrieve auth token\n        login_resp = session.post(f\"{BASE_AUTH_URL}{LOGIN_ENDPOINT}\",\n                                  json={\"email\": EMAIL, \"password\": PASSWORD},\n                                  timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n        login_data = login_resp.json()\n        assert \"token\" in login_data, \"No token found in login response\"\n        token = login_data[\"token\"]\n\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n\n        # Step 2: Get current user notification preferences\n        prefs_resp = session.get(f\"{BASE_API_URL}{USER_PREFS_ENDPOINT}\",\n                                 headers=headers,\n                                 timeout=TIMEOUT)\n        assert prefs_resp.status_code == 200, f\"Fetch preferences failed with status {prefs_resp.status_code}\"\n        user_prefs = prefs_resp.json()\n        assert isinstance(user_prefs, dict), \"User preferences response is not a dictionary\"\n\n        # Modify preferences to ensure notifications enabled (simulate user preference)\n        updated_prefs = user_prefs.copy()\n        updated_prefs.update({\"emailAlerts\": True, \"pushAlerts\": True, \"smsAlerts\": False})\n        prefs_update_resp = session.put(f\"{BASE_API_URL}{USER_PREFS_ENDPOINT}\",\n                                        headers=headers,\n                                        json=updated_prefs,\n                                        timeout=TIMEOUT)\n        assert prefs_update_resp.status_code in (200, 204), f\"Update prefs failed with status {prefs_update_resp.status_code}\"\n\n        # Step 3: Create a test notification to simulate a real-time alert\n        notification_payload = {\n            \"title\": \"Test Real-Time Alert\",\n            \"message\": \"This is a test notification for real-time alert verification.\",\n            \"type\": \"alert\",\n            \"read\": False,\n            \"timestamp\": int(time.time()*1000),\n            \"metadata\": {\"source\": \"test_case_TC009\"}\n        }\n        create_notif_resp = session.post(f\"{BASE_API_URL}{NOTIFICATIONS_ENDPOINT}\",\n                                        headers=headers,\n                                        json=notification_payload,\n                                        timeout=TIMEOUT)\n        assert create_notif_resp.status_code == 201, f\"Create notification failed with status {create_notif_resp.status_code}\"\n        notif_data = create_notif_resp.json()\n        notification_id = notif_data.get(\"id\")\n        assert notification_id, \"Notification ID not returned on creation\"\n\n        # Step 4: Validate the notification appears in the list for the user\n        list_notif_resp = session.get(f\"{BASE_API_URL}{NOTIFICATIONS_ENDPOINT}\",\n                                      headers=headers,\n                                      timeout=TIMEOUT)\n        assert list_notif_resp.status_code == 200, f\"List notifications failed with status {list_notif_resp.status_code}\"\n        notifications = list_notif_resp.json()\n        assert any(n.get(\"id\") == notification_id for n in notifications), \"Created notification not found in notification list\"\n\n        # Step 5: Mark the notification as read\n        mark_read_payload = {\"read\": True}\n        mark_read_resp = session.put(f\"{BASE_API_URL}{NOTIFICATIONS_ENDPOINT}/{notification_id}\",\n                                     headers=headers,\n                                     json=mark_read_payload,\n                                     timeout=TIMEOUT)\n        assert mark_read_resp.status_code in (200, 204), f\"Mark notification read failed with status {mark_read_resp.status_code}\"\n\n        # Step 6: Confirm notification read status updated\n        notif_detail_resp = session.get(f\"{BASE_API_URL}{NOTIFICATIONS_ENDPOINT}/{notification_id}\",\n                                        headers=headers,\n                                        timeout=TIMEOUT)\n        assert notif_detail_resp.status_code == 200, f\"Get notification detail failed with status {notif_detail_resp.status_code}\"\n        notif_detail = notif_detail_resp.json()\n        assert notif_detail.get(\"read\") is True, \"Notification read status not updated\"\n\n        # Step 7: Test user preference disables push alerts and confirm no push alert created\n        pref_disable_push = updated_prefs.copy()\n        pref_disable_push[\"pushAlerts\"] = False\n        prefs_disable_resp = session.put(f\"{BASE_API_URL}{USER_PREFS_ENDPOINT}\",\n                                        headers=headers,\n                                        json=pref_disable_push,\n                                        timeout=TIMEOUT)\n        assert prefs_disable_resp.status_code in (200, 204), f\"Disable push alerts failed with status {prefs_disable_resp.status_code}\"\n\n        # Step 8: Create another notification and verify management regarding preferences\n        second_notification_payload = {\n            \"title\": \"Test Notification With Push Disabled\",\n            \"message\": \"This notification should respect pushAlerts preference off.\",\n            \"type\": \"alert\",\n            \"read\": False,\n            \"timestamp\": int(time.time()*1000),\n            \"metadata\": {\"source\": \"test_case_TC009_second\"}\n        }\n        second_create_resp = session.post(f\"{BASE_API_URL}{NOTIFICATIONS_ENDPOINT}\",\n                                          headers=headers,\n                                          json=second_notification_payload,\n                                          timeout=TIMEOUT)\n        assert second_create_resp.status_code == 201, f\"Create second notification failed with status {second_create_resp.status_code}\"\n        second_notif_id = second_create_resp.json().get(\"id\")\n        assert second_notif_id, \"Second notification ID not returned\"\n\n        # Verify second notification exists\n        notif_list_resp_2 = session.get(f\"{BASE_API_URL}{NOTIFICATIONS_ENDPOINT}\",\n                                       headers=headers,\n                                       timeout=TIMEOUT)\n        assert notif_list_resp_2.status_code == 200, f\"List notifications failed with status {notif_list_resp_2.status_code}\"\n        notifications_2 = notif_list_resp_2.json()\n        assert any(n.get(\"id\") == second_notif_id for n in notifications_2), \"Second notification not found in list\"\n\n        # Cleanup second notification\n        del_resp2 = session.delete(f\"{BASE_API_URL}{NOTIFICATIONS_ENDPOINT}/{second_notif_id}\",\n                                   headers=headers,\n                                   timeout=TIMEOUT)\n        assert del_resp2.status_code in (200, 204), f\"Delete second notification failed with status {del_resp2.status_code}\"\n\n    finally:\n        # Cleanup: Delete the first notification if created\n        if notification_id:\n            try:\n                del_resp = session.delete(f\"{BASE_API_URL}{NOTIFICATIONS_ENDPOINT}/{notification_id}\",\n                                          headers=headers,\n                                          timeout=TIMEOUT)\n                assert del_resp.status_code in (200, 204), f\"Delete notification failed with status {del_resp.status_code}\"\n            except Exception as e:\n                print(f\"Cleanup failed for notification {notification_id}: {e}\")\n\n        # Logout\n        if token:\n            try:\n                logout_resp = session.post(f\"{BASE_AUTH_URL}{LOGOUT_ENDPOINT}\",\n                                          headers=headers,\n                                          timeout=TIMEOUT)\n                assert logout_resp.status_code == 200, f\"Logout failed with status {logout_resp.status_code}\"\n            except Exception as e:\n                print(f\"Logout failed: {e}\")\n\ntest_notification_center_real_time_alerts_and_management()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 152, in <module>\n  File \"<string>\", line 25, in test_notification_center_real_time_alerts_and_management\nAssertionError: Login failed with status 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-08T11:07:49.363Z",
    "modified": "2025-09-08T11:08:47.935Z"
  },
  {
    "projectId": "d400a9a9-6203-4b2d-9d57-a29b4e44b03f",
    "testId": "fd8ce7ce-49a1-424a-8b2d-57e1b6e7765e",
    "userId": "64789468-0061-70f5-8fc0-f9d6c509a178",
    "title": "TC010-test audit logs capture critical changes and views",
    "description": "Ensure audit logs immutably record all critical changes and views with accurate timestamps and user details.",
    "code": "import requests\nfrom datetime import datetime\nimport time\n\nBASE_AUTH_URL = \"http://localhost:8000\"\nBASE_API_URL = \"http://localhost:5173\"\nLOGIN_ENDPOINT = \"/api/auth/login\"\nLOGOUT_ENDPOINT = \"/api/auth/logout\"\nAUDIT_LOGS_ENDPOINT = \"/api/audit/logs\"\nHEADERS = {\"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\ndef test_audit_logs_capture_critical_changes_and_views():\n    session = requests.Session()\n    auth_token = None\n    user_email = 'marketing.manager@example.com'\n    user_password = 'password123'\n\n    try:\n        # Step 1: Authenticate and get token\n        login_resp = session.post(\n            f\"{BASE_AUTH_URL}{LOGIN_ENDPOINT}\",\n            json={\"email\": user_email, \"password\": user_password},\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        login_data = login_resp.json()\n        assert \"token\" in login_data, \"No token found in login response\"\n        auth_token = login_data[\"token\"]\n        auth_headers = {\n            \"Authorization\": f\"Bearer {auth_token}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        # Step 2: Perform a critical change - create a new client (simulate critical change)\n        create_client_payload = {\n            \"name\": \"Test Client Audit\",\n            \"email\": f\"testclient_{int(time.time())}@example.com\",\n            \"phone\": \"1234567890\",\n            \"address\": \"123 Audit Street\",\n            \"industry\": \"Marketing\"\n        }\n        create_client_resp = session.post(\n            f\"{BASE_API_URL}/api/clients\",\n            json=create_client_payload,\n            headers=auth_headers,\n            timeout=TIMEOUT\n        )\n        assert create_client_resp.status_code == 201, f\"Failed to create client: {create_client_resp.text}\"\n        client_data = create_client_resp.json()\n        client_id = client_data.get(\"id\")\n        assert client_id is not None, \"Created client has no ID\"\n\n        # Step 3: Simulate a view action by retrieving client details\n        read_client_resp = session.get(\n            f\"{BASE_API_URL}/api/clients/{client_id}\",\n            headers=auth_headers,\n            timeout=TIMEOUT\n        )\n        assert read_client_resp.status_code == 200, f\"Failed to get client details: {read_client_resp.text}\"\n\n        # Step 4: Fetch audit logs and validate critical entries for this client and user\n        audit_logs_resp = session.get(\n            f\"{BASE_API_URL}{AUDIT_LOGS_ENDPOINT}\",\n            headers=auth_headers,\n            timeout=TIMEOUT\n        )\n        assert audit_logs_resp.status_code == 200, f\"Failed to fetch audit logs: {audit_logs_resp.text}\"\n        audit_logs = audit_logs_resp.json()\n        assert isinstance(audit_logs, list), \"Audit logs response is not a list\"\n\n        # Filter audit logs related to the client id and user email for critical changes and views\n        related_logs = [\n            log for log in audit_logs\n            if log.get(\"resourceId\") == str(client_id)\n            and log.get(\"userEmail\") == user_email\n            and log.get(\"timestamp\") is not None\n            and log.get(\"action\") in [\"CREATE\", \"VIEW\"]\n        ]\n        assert len(related_logs) >= 2, \"Audit logs missing expected critical changes/views\"\n\n        # Validate immutable record: no duplicates with same timestamp and action for same resource and user\n        seen_entries = set()\n        for log in related_logs:\n            timestamp = log.get(\"timestamp\")\n            action = log.get(\"action\")\n            resource_id = log.get(\"resourceId\")\n            user_email_log = log.get(\"userEmail\")\n            entry_key = (timestamp, action, resource_id, user_email_log)\n            assert entry_key not in seen_entries, \"Duplicate audit log entry detected\"\n            seen_entries.add(entry_key)\n\n            # Validate timestamp format ISO8601\n            try:\n                # Some logs might have ISO8601 with timezone offset or 'Z'\n                datetime.fromisoformat(timestamp.replace(\"Z\", \"+00:00\"))\n            except Exception:\n                assert False, f\"Invalid timestamp format in log: {timestamp}\"\n\n            # Validate user details (email) matches session user\n            assert user_email_log == user_email, f\"Audit log userEmail does not match logged-in user\"\n\n    finally:\n        # Cleanup: delete created client if exists\n        if auth_token and 'client_id' in locals():\n            session.delete(\n                f\"{BASE_API_URL}/api/clients/{client_id}\",\n                headers={\"Authorization\": f\"Bearer {auth_token}\"},\n                timeout=TIMEOUT\n            )\n        # Logout to invalidate session/token\n        if auth_token:\n            session.post(\n                f\"{BASE_AUTH_URL}{LOGOUT_ENDPOINT}\",\n                headers={\"Authorization\": f\"Bearer {auth_token}\"},\n                timeout=TIMEOUT\n            )\n\ntest_audit_logs_capture_critical_changes_and_views()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 120, in <module>\n  File \"<string>\", line 27, in test_audit_logs_capture_critical_changes_and_views\nAssertionError: Login failed: {\"error\":\"Invalid credentials\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-08T11:07:49.367Z",
    "modified": "2025-09-08T11:08:49.028Z"
  }
]
