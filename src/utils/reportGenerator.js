import { jsPDF } from 'jspdf';
import * as XLSX from 'xlsx';

/**
 * Comprehensive report generation utility for PDF and Excel exports
 */

// PDF Generation Functions
export const generatePDF = {
  /**
   * Generate employee performance report PDF
   */
  employeePerformance: async (data) => {
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.getWidth();
    const margin = 20;
    let yPosition = 30;

    // Header
    doc.setFontSize(20);
    doc.setFont(undefined, 'bold');
    doc.text('EMPLOYEE PERFORMANCE REPORT', pageWidth / 2, yPosition, { align: 'center' });
    yPosition += 20;

    // Employee Info
    doc.setFontSize(14);
    doc.setFont(undefined, 'bold');
    doc.text('Employee Information', margin, yPosition);
    yPosition += 10;

    doc.setFontSize(11);
    doc.setFont(undefined, 'normal');
    doc.text(`Name: ${data.employeeName || 'N/A'}`, margin, yPosition);
    yPosition += 6;
    doc.text(`Department: ${data.department || 'N/A'}`, margin, yPosition);
    yPosition += 6;
    doc.text(`Period: ${data.period || 'N/A'}`, margin, yPosition);
    yPosition += 15;

    // Performance Metrics
    if (data.metrics) {
      doc.setFontSize(14);
      doc.setFont(undefined, 'bold');
      doc.text('Performance Metrics', margin, yPosition);
      yPosition += 10;

      doc.setFontSize(11);
      doc.setFont(undefined, 'normal');
      
      Object.entries(data.metrics).forEach(([key, value]) => {
        doc.text(`${key}: ${value}`, margin, yPosition);
        yPosition += 6;
      });
      yPosition += 10;
    }

    // Summary
    if (data.summary) {
      doc.setFontSize(14);
      doc.setFont(undefined, 'bold');
      doc.text('Summary', margin, yPosition);
      yPosition += 10;

      doc.setFontSize(11);
      doc.setFont(undefined, 'normal');
      const summaryLines = doc.splitTextToSize(data.summary, pageWidth - 2 * margin);
      summaryLines.forEach(line => {
        doc.text(line, margin, yPosition);
        yPosition += 6;
      });
    }

    // Footer
    const pageHeight = doc.internal.pageSize.getHeight();
    doc.setFontSize(8);
    doc.text(`Generated on: ${new Date().toLocaleDateString()}`, margin, pageHeight - 10);

    return doc;
  },

  /**
   * Generate monthly report PDF
   */
  monthlyReport: async (data) => {
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.getWidth();
    const margin = 20;
    let yPosition = 30;

    // Header
    doc.setFontSize(20);
    doc.setFont(undefined, 'bold');
    doc.text('MONTHLY PERFORMANCE REPORT', pageWidth / 2, yPosition, { align: 'center' });
    yPosition += 20;

    // Report Info
    doc.setFontSize(12);
    doc.setFont(undefined, 'normal');
    doc.text(`Month: ${data.month || 'N/A'}`, margin, yPosition);
    yPosition += 8;
    doc.text(`Generated by: ${data.generatedBy || 'System'}`, margin, yPosition);
    yPosition += 15;

    // Metrics Summary
    if (data.metrics) {
      doc.setFontSize(14);
      doc.setFont(undefined, 'bold');
      doc.text('Key Metrics', margin, yPosition);
      yPosition += 10;

      doc.setFontSize(11);
      doc.setFont(undefined, 'normal');
      
      Object.entries(data.metrics).forEach(([key, value]) => {
        doc.text(`${key}: ${value}`, margin, yPosition);
        yPosition += 6;
      });
      yPosition += 10;
    }

    // Department Breakdown
    if (data.departmentBreakdown && data.departmentBreakdown.length > 0) {
      doc.setFontSize(14);
      doc.setFont(undefined, 'bold');
      doc.text('Department Performance', margin, yPosition);
      yPosition += 10;

      doc.setFontSize(11);
      doc.setFont(undefined, 'normal');
      
      data.departmentBreakdown.forEach(dept => {
        doc.text(`${dept.department}: ${dept.score || 'N/A'}`, margin, yPosition);
        yPosition += 6;
      });
    }

    return doc;
  },

  /**
   * Generate incentive report PDF
   */
  incentiveReport: async (data) => {
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.getWidth();
    const margin = 20;
    let yPosition = 30;

    // Header
    doc.setFontSize(20);
    doc.setFont(undefined, 'bold');
    doc.text('INCENTIVE DISBURSEMENT REPORT', pageWidth / 2, yPosition, { align: 'center' });
    yPosition += 20;

    // Report Period
    doc.setFontSize(12);
    doc.setFont(undefined, 'normal');
    doc.text(`Period: ${data.period || 'N/A'}`, margin, yPosition);
    yPosition += 8;
    doc.text(`Total Applications: ${data.totalApplications || 0}`, margin, yPosition);
    yPosition += 8;
    doc.text(`Total Amount: ${data.totalAmount || 'N/A'}`, margin, yPosition);
    yPosition += 15;

    // Applications Table
    if (data.applications && data.applications.length > 0) {
      doc.setFontSize(14);
      doc.setFont(undefined, 'bold');
      doc.text('Incentive Applications', margin, yPosition);
      yPosition += 10;

      // Table headers
      doc.setFontSize(10);
      doc.setFont(undefined, 'bold');
      doc.text('Employee', margin, yPosition);
      doc.text('Type', margin + 60, yPosition);
      doc.text('Amount', margin + 120, yPosition);
      doc.text('Status', margin + 160, yPosition);
      yPosition += 8;

      // Table data
      doc.setFont(undefined, 'normal');
      data.applications.slice(0, 20).forEach(app => { // Limit to first 20 for space
        doc.text(app.employeeName || 'N/A', margin, yPosition);
        doc.text(app.incentiveType || 'N/A', margin + 60, yPosition);
        doc.text(app.amount?.toString() || 'N/A', margin + 120, yPosition);
        doc.text(app.status || 'N/A', margin + 160, yPosition);
        yPosition += 6;
      });
    }

    return doc;
  }
};

// Excel Generation Functions
export const generateExcel = {
  /**
   * Generate employee performance Excel report
   */
  employeePerformance: (data) => {
    const workbook = XLSX.utils.book_new();
    
    // Employee Info Sheet
    const employeeInfo = [
      ['Employee Information'],
      ['Name', data.employeeName || 'N/A'],
      ['Department', data.department || 'N/A'],
      ['Period', data.period || 'N/A'],
      ['Generated On', new Date().toLocaleDateString()]
    ];
    
    if (data.metrics) {
      employeeInfo.push([''], ['Performance Metrics']);
      Object.entries(data.metrics).forEach(([key, value]) => {
        employeeInfo.push([key, value]);
      });
    }
    
    const ws1 = XLSX.utils.aoa_to_sheet(employeeInfo);
    XLSX.utils.book_append_sheet(workbook, ws1, 'Employee Info');
    
    // Performance Data Sheet (if available)
    if (data.performanceData && Array.isArray(data.performanceData)) {
      const ws2 = XLSX.utils.json_to_sheet(data.performanceData);
      XLSX.utils.book_append_sheet(workbook, ws2, 'Performance Data');
    }
    
    return workbook;
  },

  /**
   * Generate monthly report Excel
   */
  monthlyReport: (data) => {
    const workbook = XLSX.utils.book_new();
    
    // Summary Sheet
    const summary = [
      ['Monthly Performance Report'],
      ['Month', data.month || 'N/A'],
      ['Generated By', data.generatedBy || 'System'],
      ['Generated On', new Date().toLocaleDateString()],
      ['']
    ];
    
    if (data.metrics) {
      summary.push(['Key Metrics']);
      Object.entries(data.metrics).forEach(([key, value]) => {
        summary.push([key, value]);
      });
    }
    
    const ws1 = XLSX.utils.aoa_to_sheet(summary);
    XLSX.utils.book_append_sheet(workbook, ws1, 'Summary');
    
    // Department Breakdown Sheet
    if (data.departmentBreakdown && Array.isArray(data.departmentBreakdown)) {
      const ws2 = XLSX.utils.json_to_sheet(data.departmentBreakdown);
      XLSX.utils.book_append_sheet(workbook, ws2, 'Department Breakdown');
    }
    
    return workbook;
  },

  /**
   * Generate incentive report Excel
   */
  incentiveReport: (data) => {
    const workbook = XLSX.utils.book_new();
    
    // Summary Sheet
    const summary = [
      ['Incentive Disbursement Report'],
      ['Period', data.period || 'N/A'],
      ['Total Applications', data.totalApplications || 0],
      ['Total Amount', data.totalAmount || 'N/A'],
      ['Generated On', new Date().toLocaleDateString()]
    ];
    
    const ws1 = XLSX.utils.aoa_to_sheet(summary);
    XLSX.utils.book_append_sheet(workbook, ws1, 'Summary');
    
    // Applications Sheet
    if (data.applications && Array.isArray(data.applications)) {
      const ws2 = XLSX.utils.json_to_sheet(data.applications);
      XLSX.utils.book_append_sheet(workbook, ws2, 'Applications');
    }
    
    return workbook;
  },

  /**
   * Generate generic data export Excel
   */
  genericData: (data, sheetName = 'Data') => {
    const workbook = XLSX.utils.book_new();
    
    if (Array.isArray(data)) {
      const ws = XLSX.utils.json_to_sheet(data);
      XLSX.utils.book_append_sheet(workbook, ws, sheetName);
    } else {
      // Convert object to array format
      const arrayData = Object.entries(data).map(([key, value]) => ({ Key: key, Value: value }));
      const ws = XLSX.utils.json_to_sheet(arrayData);
      XLSX.utils.book_append_sheet(workbook, ws, sheetName);
    }
    
    return workbook;
  }
};

// Download Functions
export const downloadFile = {
  /**
   * Download PDF file
   */
  pdf: (doc, filename) => {
    doc.save(`${filename}.pdf`);
  },

  /**
   * Download Excel file
   */
  excel: (workbook, filename) => {
    XLSX.writeFile(workbook, `${filename}.xlsx`);
  },

  /**
   * Download CSV file
   */
  csv: (data, filename) => {
    let csvContent;
    
    if (Array.isArray(data)) {
      if (data.length === 0) return;
      
      const headers = Object.keys(data[0]);
      csvContent = [
        headers.join(','),
        ...data.map(row => headers.map(header => {
          const value = row[header];
          // Escape commas and quotes in CSV
          if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
            return `"${value.replace(/"/g, '""')}"`;
          }
          return value;
        }).join(','))
      ].join('\n');
    } else {
      // Convert object to CSV
      csvContent = Object.entries(data)
        .map(([key, value]) => `${key},${value}`)
        .join('\n');
    }
    
    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${filename}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
};

// Utility Functions
export const reportUtils = {
  /**
   * Generate filename with timestamp
   */
  generateFilename: (baseName, extension = '') => {
    const timestamp = new Date().toISOString().split('T')[0];
    return `${baseName}_${timestamp}${extension ? '.' + extension : ''}`;
  },

  /**
   * Format data for reports
   */
  formatReportData: (rawData, type = 'employee') => {
    switch (type) {
      case 'employee':
        return {
          employeeName: rawData.name || rawData.employeeName,
          department: rawData.department,
          period: rawData.period || rawData.month,
          metrics: rawData.metrics || rawData.scores,
          summary: rawData.summary || rawData.notes,
          performanceData: rawData.performanceData || rawData.monthlyData
        };
      
      case 'monthly':
        return {
          month: rawData.month,
          generatedBy: rawData.generatedBy,
          metrics: rawData.metrics,
          departmentBreakdown: rawData.departmentBreakdown
        };
      
      case 'incentive':
        return {
          period: rawData.period,
          totalApplications: rawData.applications?.length || 0,
          totalAmount: rawData.applications?.reduce((sum, app) => sum + (app.amount || 0), 0),
          applications: rawData.applications
        };
      
      default:
        return rawData;
    }
  }
};

// Main export function for easy use
export const exportReport = async (data, format, type, filename) => {
  try {
    const formattedData = reportUtils.formatReportData(data, type);
    const baseFilename = filename || reportUtils.generateFilename(`${type}_report`);
    
    switch (format.toLowerCase()) {
      case 'pdf':
        const doc = await generatePDF[type](formattedData);
        downloadFile.pdf(doc, baseFilename);
        break;
      
      case 'excel':
      case 'xlsx':
        const workbook = generateExcel[type](formattedData);
        downloadFile.excel(workbook, baseFilename);
        break;
      
      case 'csv':
        downloadFile.csv(formattedData, baseFilename);
        break;
      
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
    
    return { success: true, message: `${format.toUpperCase()} report generated successfully` };
  } catch (error) {
    console.error('Error generating report:', error);
    return { success: false, message: `Failed to generate report: ${error.message}` };
  }
};